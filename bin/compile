#!/usr/bin/env bash
# Usage: compile BUILD_DIR CACHE_DIR ENV_DIR
BUILD_DIR=$(cd $1 && pwd)
CACHE_DIR=$(cd $2 && pwd)
ENV_DIR=$(cd $3 && pwd)

# The heroku-buildpack-elixir uses a generic function for this. Meh.
export DATABASE_URL=$(cat $ENV_DIR/DATABASE_URL)
export POOL_SIZE=$(cat $ENV_DIR/POOL_SIZE)
export PORT=$(cat $ENV_DIR/PORT)
export SECRET_KEY_BASE=$(cat $ENV_DIR/SECRET_KEY_BASE)
export SECRET_KEY_GUARDIAN=$(cat $ENV_DIR/SECRET_KEY_GUARDIAN)
export KLEINPLAN_GRAPHQL_API_URL=$(cat $ENV_DIR/KLEINPLAN_GRAPHQL_API_URL)

echo "-----> Precompiling Kleinplan specific assets..."

# See https://ss64.com/bash/set.html
set -o errexit   # Always exit on error
set -o pipefail  # Don't ignore exit codes when piping output
set -o xtrace    # Echo all commands as they are executed

# We operate in the temporary directory where the release is being prepared
cd $BUILD_DIR

# The following mix task will fail on Heroku if this file is missing, hence we create a dummy
mkdir -p priv/static && touch priv/static/cache_manifest.json

# Absinthe only works right when freshly installed... :/
mix deps.clean absinthe
mix deps.get
mix compile

# Generate the GraphQL schema from elixir sources
mix absinthe.schema.json ./priv/static/schema.json --json-codec Poison --pretty true

# Remove the dummy (empty files are hard to digest)
rm priv/static/cache_manifest.json

# Compile the GUI (jepp, we need those devDependencies, too)
NPM_ENV=development npm install
$(npm bin)/apollo client:codegen --target=typescript --outputFlat ./lib/kleinplan_gui/store/GraphqlTypes.ts
$(npm bin)/webpack --profile --display-modules

# Now produce the asset digests and the real cache_manifest.json
mix phx.digest priv/static
